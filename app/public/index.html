<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Costcodle Score Dashboard</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            background: rgba(255, 255, 255, 0.95);
            padding: 30px;
            border-radius: 20px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }

        .header h1 {
            font-size: 2.5em;
            color: #4a5568;
            margin-bottom: 10px;
        }

        .header p {
            color: #718096;
            font-size: 1.1em;
        }

        .controls {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 30px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
        }

        .controls button {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            margin-right: 10px;
            transition: background 0.3s;
        }

        .controls button:hover {
            background: #5a6fd8;
        }

        .controls button.head-to-head {
            background: #e74c3c;
        }

        .controls button.head-to-head:hover {
            background: #c0392b;
        }

        .controls button.head-to-head.active {
            background: #c0392b;
            box-shadow: 0 0 10px rgba(231, 76, 60, 0.3);
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: auto auto auto auto;
            gap: 30px;
            margin-bottom: 30px;
        }

        /* Full-width line charts */
        .full-width {
            grid-column: 1 / -1;
        }

        /* Wide screens get 3 columns x 4 rows */
        @media (min-width: 1400px) {
            .grid {
                grid-template-columns: repeat(3, 1fr);
                grid-template-rows: auto auto auto auto;
            }
        }

        /* Mobile gets single column */
        @media (max-width: 768px) {
            .grid {
                grid-template-columns: 1fr;
            }

            .container {
                padding: 10px;
            }
        }

        .card {
            background: rgba(255, 255, 255, 0.95);
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
        }

        .card h2 {
            color: #4a5568;
            margin-bottom: 20px;
            font-size: 1.5em;
        }

        .chart-container {
            position: relative;
            height: 400px;
            margin-bottom: 20px;
        }

        .stats-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }

        .stats-table th,
        .stats-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #e2e8f0;
        }

        .stats-table th {
            background: #f7fafc;
            color: #4a5568;
            font-weight: 600;
        }

        .stats-table tr:hover {
            background: #f9fafb;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #718096;
        }

        .error {
            background: #fed7d7;
            color: #c53030;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .success {
            background: #c6f6d5;
            color: #2d7748;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8em;
            font-weight: 600;
            color: white;
        }

        .badge.best {
            background: #48bb78;
        }

        .badge.good {
            background: #4299e1;
        }

        .badge.average {
            background: #ed8936;
        }

        .badge.poor {
            background: #f56565;
        }

        .achievement-item {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            margin: 4px 0;
            border-radius: 6px;
            background: #f8f9fa;
            border-left: 3px solid #48bb78;
            font-size: 14px;
        }

        .achievement-item .icon {
            font-size: 18px;
            margin-right: 10px;
            width: 24px;
            text-align: center;
        }

        .achievement-details {
            flex-grow: 1;
        }

        .achievement-title {
            font-weight: bold;
            color: #4a5568;
        }

        .achievement-desc {
            font-size: 12px;
            color: #666;
            margin-top: 2px;
        }

        .user-achievements {
            margin-bottom: 15px;
        }

        .user-achievements h4 {
            color: #667eea;
            margin-bottom: 8px;
            font-size: 16px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üõí Costcodle Dashboard</h1>
            <p>Track your group's Costcodle performance over time</p>
        </div>

        <div class="controls">
            <button id="refreshBtn">Refresh Data</button>
            <button id="exportBtn">Export CSV</button>
            <button id="headToHeadBtn" class="head-to-head">‚öîÔ∏è Head to Head</button>
            <span id="lastUpdate" style="margin-left: 20px; color: #666;"></span>
        </div>

        <div id="message"></div>

        <div class="grid">
            <div class="card full-width">
                <h2>üìä User Statistics</h2>
                <div id="userStats" class="loading">Loading...</div>
            </div>

            <div class="card">
                <h2>üèÜ Monthly Leaderboard</h2>
                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 15px;">
                    <button id="prevMonthBtn" style="background: #667eea; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 14px;">‚Üê Previous</button>
                    <span id="currentMonthDisplay" style="font-weight: bold; color: #667eea;"></span>
                    <button id="nextMonthBtn" style="background: #667eea; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 14px;">Next ‚Üí</button>
                </div>
                <div id="monthlyLeaderboard" class="loading">Loading...</div>
            </div>

            <div class="card">
                <h2>üèÜ Score Distribution</h2>
                <div class="chart-container">
                    <canvas id="distributionChart"></canvas>
                </div>
            </div>

            <div class="card">
                <h2>üìà Performance Summary</h2>
                <div id="performanceSummary" class="loading">Loading...</div>
            </div>

            <div class="card full-width">
                <h2>üéñÔ∏è Achievements</h2>
                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 15px;">
                    <button id="toggleAchievementsBtn" style="background: #667eea; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 14px;">Hide All</button>
                    <span style="font-size: 14px; color: #666;">Click on a player name in User Statistics to see their achievements</span>
                    <div></div>
                </div>
                <div id="achievementsWidget" class="loading">Loading...</div>
            </div>

            <div class="card full-width">
                <h2>üìà Average Score Trends</h2>
                <div class="chart-container">
                    <canvas id="trendsChart"></canvas>
                </div>
            </div>

            <div class="card full-width">
                <h2>üìÖ Daily Performance</h2>
                <div class="chart-container">
                    <canvas id="dailyChart"></canvas>
                </div>
            </div>

            <div class="card full-width">
                <h2>üéØ Individual Progress</h2>
                <div class="chart-container">
                    <canvas id="progressChart"></canvas>
                </div>
            </div>

            <div class="card full-width">
                <h2>üóìÔ∏è Score Heatmap</h2>
                <div id="heatmapContainer" style="height: 700px; overflow-x: auto;">
                    <div id="scoreHeatmap"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let allScores = [];
        let userStats = [];
        let dailyStats = [];
        let currentMonthOffset = 0; // 0 = current month, -1 = previous month, etc.
        let userAchievements = {}; // Store achievements for all users
        let achievementsExpanded = true; // Track if achievements are expanded
        let headToHeadMode = false; // Track if head-to-head mode is active

        // Hardcoded channel ID - INPUT CHANNEL ID
        const CHANNEL_ID = '';

        // API base URL - adjust this to your server
        const API_BASE = window.location.origin + '/api';

        // Head-to-head players
        const HEAD_TO_HEAD_PLAYERS = ['.cyco', 'clicky6792'];

        // Filter data for head-to-head mode
        function filterDataForHeadToHead(data) {
            if (!headToHeadMode) return data;
            return data.filter(item => HEAD_TO_HEAD_PLAYERS.includes(item.username));
        }

        // Initialize dashboard
        async function init() {
            await refreshData();

            // Set up event listeners
            document.getElementById('refreshBtn').addEventListener('click', refreshData);
            document.getElementById('exportBtn').addEventListener('click', exportData);
            document.getElementById('headToHeadBtn').addEventListener('click', toggleHeadToHead);
            document.getElementById('prevMonthBtn').addEventListener('click', () => {
                currentMonthOffset--;
                updateMonthlyLeaderboard();
            });
            document.getElementById('nextMonthBtn').addEventListener('click', () => {
                if (currentMonthOffset < 0) { // Don't go future from current month
                    currentMonthOffset++;
                    updateMonthlyLeaderboard();
                }
            });
            document.getElementById('toggleAchievementsBtn').addEventListener('click', () => {
                toggleAllAchievements();
            });

            // Add event delegation for clickable usernames
            document.addEventListener('click', (e) => {
                if (e.target.classList.contains('player-name')) {
                    const username = e.target.textContent;
                    showUserAchievements(username);
                }
            });
        }

        // Store chart instances globally for proper cleanup
        let trendsChart = null;
        let distributionChart = null;
        let dailyChart = null;
        let progressChart = null;

        // Toggle head-to-head mode
        function toggleHeadToHead() {
            headToHeadMode = !headToHeadMode;
            const btn = document.getElementById('headToHeadBtn');

            if (headToHeadMode) {
                btn.textContent = 'Show All Players';
                btn.classList.add('active');
                showMessage('Head-to-Head mode: Showing only .cyco vs clicky6792', 'info');
            } else {
                btn.textContent = '‚öîÔ∏è Head to Head';
                btn.classList.remove('active');
                showMessage('Showing all players', 'info');
            }

            // Destroy existing charts before recreating
            if (trendsChart) {
                trendsChart.destroy();
                trendsChart = null;
            }
            if (distributionChart) {
                distributionChart.destroy();
                distributionChart = null;
            }
            if (dailyChart) {
                dailyChart.destroy();
                dailyChart = null;
            }
            if (progressChart) {
                progressChart.destroy();
                progressChart = null;
            }

            // Refresh all widgets with new filter
            updateUserStatsTable();
            updateTrendsChart();
            updateDistributionChart();
            updateDailyChart();
            updateProgressChart();
            updateScoreHeatmap();
            updatePerformanceSummary();
            updateAchievements();
            updateAchievementsWidget();
            updateMonthlyLeaderboard();
        }

        // Refresh all data
        async function refreshData() {
            try {
                showMessage('Refreshing data...', 'info');

                // Fetch all data
                const [scoresResponse, usersResponse, dailyResponse] = await Promise.all([
                    fetch(`${API_BASE}/scores?limit=10000`), // Increase limit to get all scores
                    fetch(`${API_BASE}/users`),
                    fetch(`${API_BASE}/daily-stats`)
                ]);

                // Check if responses are ok
                if (!scoresResponse.ok) {
                    throw new Error(`Scores API error: ${scoresResponse.status}`);
                }
                if (!usersResponse.ok) {
                    throw new Error(`Users API error: ${usersResponse.status}`);
                }
                if (!dailyResponse.ok) {
                    throw new Error(`Daily stats API error: ${dailyResponse.status}`);
                }

                const scoresData = await scoresResponse.json();
                const usersData = await usersResponse.json();
                const dailyData = await dailyResponse.json();

                // Validate data types
                allScores = Array.isArray(scoresData) ? scoresData : [];
                userStats = Array.isArray(usersData) ? usersData : [];
                dailyStats = Array.isArray(dailyData) ? dailyData : [];

                console.log('Data loaded:', {
                    scores: allScores.length,
                    users: userStats.length,
                    daily: dailyStats.length
                });

                // Check if this looks like a fresh database
                if (allScores.length === 0) {
                    showMessage('No data found. If this is a new setup, the bot may be importing historical data in the background. Please wait a moment and refresh again.', 'info');
                    document.getElementById('lastUpdate').textContent = 'Waiting for initial data import...';
                } else {
                    // Update all displays
                    updateUserStatsTable();
                    updateTrendsChart();
                    updateDistributionChart();
                    updateDailyChart();
                    updateProgressChart();
                    updateScoreHeatmap();
                    updatePerformanceSummary();
                    updateAchievements(); // Calculate achievements first
                    updateAchievementsWidget(); // Then update the widget
                    updateMonthlyLeaderboard();

                    showMessage('Data refreshed successfully!', 'success');
                    document.getElementById('lastUpdate').textContent = `Last updated: ${new Date().toLocaleTimeString()}`;
                }
            } catch (error) {
                console.error('Refresh error:', error);
                showMessage('Error refreshing data: ' + error.message, 'error');

                // Initialize empty arrays on error
                allScores = [];
                userStats = [];
                dailyStats = [];
            }
        }

        // Show message to user
        function showMessage(text, type) {
            const messageDiv = document.getElementById('message');
            messageDiv.innerHTML = `<div class="${type}">${text}</div>`;
            if (type === 'success' || type === 'info') {
                setTimeout(() => {
                    messageDiv.innerHTML = '';
                }, 3000);
            }
        }

        // Update user statistics table with enhanced data and achievement icons
        function updateUserStatsTable() {
            const container = document.getElementById('userStats');

            if (userStats.length === 0 || allScores.length === 0) {
                container.innerHTML = '<p>No data available</p>';
                return;
            }

            // Filter user stats for head-to-head mode
            const filteredUserStats = filterDataForHeadToHead(userStats);

            if (filteredUserStats.length === 0) {
                container.innerHTML = '<p>No data available for selected players</p>';
                return;
            }

            // Calculate additional stats for each user
            const enhancedStats = filteredUserStats.map(user => {
                const userScores = allScores.filter(s => s.username === user.username);

                // Sort by date for streak and date calculations
                const sortedScores = userScores.sort((a, b) => new Date(a.date) - new Date(b.date));

                // Calculate dates
                const firstDate = sortedScores.length > 0 ? sortedScores[0].date : 'N/A';
                const lastDate = sortedScores.length > 0 ? sortedScores[sortedScores.length - 1].date : 'N/A';
                const mostRecentScore = sortedScores.length > 0 ?
                    (sortedScores[sortedScores.length - 1].failed ? 'X' : sortedScores[sortedScores.length - 1].score) : 'N/A';

                // Calculate daily wins
                const dailyWins = calculateDailyWins(user.username);

                // Calculate streaks
                const streakData = calculateStreaks(userScores);

                return {
                    ...user,
                    first_date: firstDate,
                    last_date: lastDate,
                    most_recent_score: mostRecentScore,
                    daily_wins: dailyWins,
                    longest_streak: streakData.maxStreak,
                    current_streak: streakData.currentStreak
                };
            });

            let html = `
                <table class="stats-table">
                    <thead>
                        <tr>
                            <th>Player</th>
                            <th>Games</th>
                            <th>Avg Score</th>
                            <th>Best</th>
                            <th>Performance</th>
                            <th>First Played</th>
                            <th>Last Played</th>
                            <th>Recent Score</th>
                            <th>Daily Wins</th>
                            <th>Longest Streak</th>
                            <th>Current Streak</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            enhancedStats.forEach(user => {
                const avgScore = parseFloat(user.avg_score).toFixed(2);
                const badge = getPerformanceBadge(user.avg_score);

                html += `
                    <tr>
                        <td><strong><span class="player-name" style="cursor: pointer; color: #667eea;">${user.username}</span></strong></td>
                        <td>${user.total_games}</td>
                        <td>${avgScore}</td>
                        <td>${user.best_score}</td>
                        <td><span class="badge ${badge.class}">${badge.text}</span></td>
                        <td>${user.first_date}</td>
                        <td>${user.last_date}</td>
                        <td>${user.most_recent_score}/6</td>
                        <td>${user.daily_wins}</td>
                        <td style="color: #48bb78">${user.longest_streak}</td>
                        <td style="color: ${user.current_streak > 0 ? '#48bb78' : '#666'}">${user.current_streak}</td>
                    </tr>
                `;
            });

            html += '</tbody></table>';
            container.innerHTML = html;
        }

        // Update achievements widget - now full width with better layout
        function updateAchievementsWidget(specificUser = null) {
            const container = document.getElementById('achievementsWidget');

            if (Object.keys(userAchievements).length === 0) {
                container.innerHTML = '<p>No achievements available</p>';
                return;
            }

            // Filter to specific user if requested, or apply head-to-head filter
            let usersToShow;
            if (specificUser) {
                usersToShow = [[specificUser, userAchievements[specificUser] || []]];
            } else {
                // Apply head-to-head filter if active
                usersToShow = Object.entries(userAchievements)
                    .filter(([username, achievements]) => {
                        if (!headToHeadMode) return achievements.length > 0;
                        return HEAD_TO_HEAD_PLAYERS.includes(username) && achievements.length > 0;
                    })
                    .sort((a, b) => b[1].length - a[1].length);
            }

            if (usersToShow.length === 0) {
                container.innerHTML = '<p>No achievements earned yet</p>';
                return;
            }

            // Create a grid layout for better use of space
            let html = '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap: 20px;">';

            usersToShow.forEach(([username, achievements]) => {
                if (achievements.length === 0) {
                    html += `
                        <div class="user-achievements" style="border: 1px solid #e2e8f0; border-radius: 8px; padding: 15px; background: #f8f9fa;">
                            <h4 style="margin-bottom: 12px; padding-bottom: 8px; border-bottom: 2px solid #667eea;">${username} (No achievements yet)</h4>
                            <p style="color: #666; font-style: italic;">Keep playing to earn achievements!</p>
                        </div>
                    `;
                    return;
                }

                html += `
                    <div class="user-achievements" style="border: 1px solid #e2e8f0; border-radius: 8px; padding: 15px; background: #f8f9fa;">
                        <h4 style="margin-bottom: 12px; padding-bottom: 8px; border-bottom: 2px solid #667eea;">${username} (${achievements.length})</h4>
                `;

                achievements.forEach(achievement => {
                    html += `
                        <div class="achievement-item">
                            <div class="icon">${achievement.icon}</div>
                            <div class="achievement-details">
                                <div class="achievement-title">${achievement.title}</div>
                                <div class="achievement-desc">${achievement.desc}</div>
                                ${achievement.progress ? `<div class="achievement-desc" style="color: #888; font-style: italic;">${achievement.progress}</div>` : ''}
                            </div>
                        </div>
                    `;
                });

                html += '</div>';
            });

            html += '</div>';

            // Add "Show All" button if showing specific user
            if (specificUser) {
                html += '<div style="text-align: center; margin-top: 20px;"><button onclick="updateAchievementsWidget()" style="background: #667eea; color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer;">Show All Players</button></div>';
            }

            container.innerHTML = html;
        }

        // Show achievements for a specific user
        function showUserAchievements(username) {
            if (!userAchievements[username] || userAchievements[username].length === 0) {
                alert(`${username} has no achievements yet!`);
                return;
            }

            // Expand achievements if collapsed
            if (!achievementsExpanded) {
                toggleAllAchievements();
            }

            // Update widget to show only this user
            updateAchievementsWidget(username);

            // Scroll to achievements
            document.getElementById('achievementsWidget').scrollIntoView({ behavior: 'smooth' });
        }

        // Toggle all achievements visibility
        function toggleAllAchievements() {
            const widget = document.getElementById('achievementsWidget');
            const button = document.getElementById('toggleAchievementsBtn');

            if (achievementsExpanded) {
                widget.style.display = 'none';
                button.textContent = 'Show All';
                achievementsExpanded = false;
            } else {
                widget.style.display = 'block';
                button.textContent = 'Hide All';
                achievementsExpanded = true;
                updateAchievementsWidget(); // Show all users again
            }
        }

        function calculateDailyWins(username) {
            // Filter scores for head-to-head mode
            const scoresToConsider = headToHeadMode ?
                allScores.filter(s => HEAD_TO_HEAD_PLAYERS.includes(s.username)) :
                allScores;

            const dailyScores = {};
            scoresToConsider.forEach(score => {
                if (!dailyScores[score.date]) {
                    dailyScores[score.date] = [];
                }
                if (!score.failed) {
                    dailyScores[score.date].push({
                        username: score.username,
                        score: score.score
                    });
                }
            });

            let wins = 0;
            Object.values(dailyScores).forEach(dayScores => {
                if (dayScores.length > 0) {
                    const bestScore = Math.min(...dayScores.map(s => s.score));
                    const winners = dayScores.filter(s => s.score === bestScore);
                    const userWon = winners.some(w => w.username === username);
                    if (userWon) {
                        wins += 1 / winners.length; // Split ties
                    }
                }
            });

            return wins.toFixed(1);
        }

        // Calculate streak data for a user
        function calculateStreaks(userScores) {
            const sortedScores = userScores.sort((a, b) => new Date(a.date) - new Date(b.date));

            let currentStreak = 0;
            let maxStreak = 0;

            sortedScores.forEach(score => {
                // Good streak (score <= 3 and not failed)
                if (!score.failed && score.score <= 3) {
                    currentStreak++;
                    maxStreak = Math.max(maxStreak, currentStreak);
                } else {
                    currentStreak = 0;
                }
            });

            return { currentStreak, maxStreak };
        }

        // Update monthly leaderboard with navigation
        function updateMonthlyLeaderboard() {
            const container = document.getElementById('monthlyLeaderboard');

            if (allScores.length === 0) {
                container.innerHTML = '<p>No data available</p>';
                return;
            }

            // Calculate target month
            const now = new Date();
            const targetDate = new Date(now.getFullYear(), now.getMonth() + currentMonthOffset, 1);
            const targetMonth = targetDate.getFullYear() + '-' + String(targetDate.getMonth() + 1).padStart(2, '0');

            // Update month display and button states
            const monthName = targetDate.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
            document.getElementById('currentMonthDisplay').textContent = monthName;

            // Enable/disable next button (can't go future from current month)
            const nextBtn = document.getElementById('nextMonthBtn');
            nextBtn.disabled = currentMonthOffset >= 0;
            nextBtn.style.opacity = currentMonthOffset >= 0 ? '0.5' : '1';
            nextBtn.style.cursor = currentMonthOffset >= 0 ? 'not-allowed' : 'pointer';

            // Filter scores for target month and head-to-head mode
            let monthScores = allScores.filter(score => {
                const scoreMonth = score.date.substring(0, 7); // YYYY-MM
                return scoreMonth === targetMonth;
            });

            if (headToHeadMode) {
                monthScores = monthScores.filter(score => HEAD_TO_HEAD_PLAYERS.includes(score.username));
            }

            if (monthScores.length === 0) {
                container.innerHTML = '<p>No scores for this month</p>';
                return;
            }

            // Calculate monthly stats per user
            const monthlyStats = {};
            monthScores.forEach(score => {
                if (!monthlyStats[score.username]) {
                    monthlyStats[score.username] = {
                        username: score.username,
                        games: 0,
                        totalScore: 0,
                        completedGames: 0,
                        failed: 0,
                        bestScore: 6,
                        points: 0
                    };
                }

                const user = monthlyStats[score.username];
                user.games++;

                if (score.failed) {
                    user.failed++;
                    user.points += 7; // X = 7 points (golf scoring)
                } else {
                    user.completedGames++;
                    user.totalScore += score.score;
                    user.bestScore = Math.min(user.bestScore, score.score);
                    user.points += score.score; // Golf scoring: 1=1pt, 2=2pts, etc.
                }
            });

            // Convert to array and calculate averages
            const leaderboard = Object.values(monthlyStats).map(user => {
                user.avgScore = user.completedGames > 0 ? (user.totalScore / user.completedGames).toFixed(2) : 'N/A';
                user.avgPoints = user.games > 0 ? (user.points / user.games).toFixed(2) : 'N/A';
                return user;
            });

            // Sort by average points (lowest first - golf scoring), then by total games as tiebreaker
            leaderboard.sort((a, b) => {
                if (a.avgPoints === 'N/A') return 1;
                if (b.avgPoints === 'N/A') return -1;
                const pointDiff = parseFloat(a.avgPoints) - parseFloat(b.avgPoints);
                if (pointDiff !== 0) return pointDiff;
                return b.games - a.games; // More games played as tiebreaker
            });

            let html = `
                <table class="stats-table">
                    <thead>
                        <tr>
                            <th>Rank</th>
                            <th>Player</th>
                            <th>Avg Points</th>
                            <th>Games</th>
                            <th>Avg Score</th>
                            <th>Best</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            leaderboard.forEach((user, index) => {
                const rankIcon = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : `${index + 1}.`;

                html += `
                    <tr style="${index < 3 ? 'background: #f8f9fa;' : ''}">
                        <td style="text-align: center;">${rankIcon}</td>
                        <td><strong>${user.username}</strong></td>
                        <td style="color: #667eea; font-weight: bold;">${user.avgPoints}</td>
                        <td>${user.games}</td>
                        <td>${user.avgScore}</td>
                        <td>${user.bestScore === 6 ? 'N/A' : user.bestScore}</td>
                    </tr>
                `;
            });

            html += '</tbody></table>';
            html += '<div style="margin-top: 10px; font-size: 12px; color: #666; text-align: center;">Golf Scoring: 1=1pt, 2=2pts, 3=3pts, 4=4pts, 5=5pts, 6=6pts, X=7pts (Lower is better)</div>';

            container.innerHTML = html;
        }

        // Update achievements system - now calculates for all users and stores globally
        function updateAchievements() {
            if (allScores.length === 0) {
                userAchievements = {};
                return;
            }

            // Calculate achievements for each user
            userAchievements = {};
            const users = [...new Set(allScores.map(s => s.username))];

            users.forEach(username => {
                const userScores = allScores.filter(s => s.username === username);
                const completedScores = userScores.filter(s => !s.failed);
                const sortedScores = userScores.sort((a, b) => new Date(a.date) - new Date(b.date));

                const achievements = [];

                // First Blood - First person to submit a score each day
                if (allScores.length > 0) {
                    const firstEverDate = Math.min(...allScores.map(s => new Date(s.date)));
                    const userFirstDate = userScores.length > 0 ? Math.min(...userScores.map(s => new Date(s.date))) : null;
                    if (userFirstDate && userFirstDate === firstEverDate) {
                        achievements.push({ icon: 'ü©∏', title: 'First Blood', desc: 'First to submit a Costcodle score', earned: true });
                    }
                }

                // Perfect Game - Score of 1
                const perfectGames = completedScores.filter(s => s.score === 1).length;

                if (perfectGames > 0) {
                    achievements.push({
                        icon: 'üéØ',
                        title: 'Perfect Game',
                        desc: 'Score of 1',
                        earned: true,
                        progress: `${perfectGames} perfect game${perfectGames !== 1 ? 's' : ''}`
                    });

                    // Hat Trick - 3 perfect games
                    if (perfectGames >= 3) {
                        achievements.push({
                            icon: 'üé©',
                            title: 'Hat Trick',
                            desc: '3 perfect games',
                            earned: true,
                            progress: `${perfectGames} perfect games`
                        });
                    }

                    // Perfect Ten - 10 perfect games
                    if (perfectGames >= 10) {
                        achievements.push({
                            icon: 'üíé',
                            title: 'Perfect Ten',
                            desc: '10 perfect games',
                            earned: true,
                            progress: `${perfectGames} perfect games`
                        });
                    }

                    // Legendary - 25 perfect games
                    if (perfectGames >= 25) {
                        achievements.push({
                            icon: 'üëë',
                            title: 'Legendary',
                            desc: '25 perfect games',
                            earned: true,
                            progress: `${perfectGames} perfect games`
                        });
                    }

                    // Perfect Streak - 3 perfect games in a row
                    let currentStreak = 0;
                    let maxPerfectStreak = 0;
                    sortedScores.forEach(score => {
                        if (!score.failed && score.score === 1) {
                            currentStreak++;
                            maxPerfectStreak = Math.max(maxPerfectStreak, currentStreak);
                        } else {
                            currentStreak = 0;
                        }
                    });
                    if (maxPerfectStreak >= 3) {
                        achievements.push({
                            icon: '‚≠ê',
                            title: 'Perfect Streak',
                            desc: '3 perfect games in a row',
                            earned: true,
                            progress: `Best perfect streak: ${maxPerfectStreak}`
                        });
                    }
                }

                // Consistency King - 10+ games with avg ‚â§ 3.0
                const avgScore = completedScores.length > 0 ?
                    completedScores.reduce((sum, s) => sum + s.score, 0) / completedScores.length : 6;
                if (completedScores.length >= 10 && avgScore <= 3.0) {
                    achievements.push({
                        icon: '‚öñÔ∏è',
                        title: 'Consistency King',
                        desc: '10+ games with avg ‚â§ 3.0',
                        earned: true,
                        progress: `${completedScores.length} games, ${avgScore.toFixed(2)} avg`
                    });
                }

                // Elite Player - 20+ games with avg ‚â§ 2.5
                if (completedScores.length >= 20 && avgScore <= 2.5) {
                    achievements.push({
                        icon: 'üèÖ',
                        title: 'Elite Player',
                        desc: '20+ games with avg ‚â§ 2.5',
                        earned: true,
                        progress: `${completedScores.length} games, ${avgScore.toFixed(2)} avg`
                    });
                }

                // Hot Streak - 5 games in a row ‚â§ 3
                let currentStreak = 0;
                let maxStreak = 0;
                sortedScores.forEach(score => {
                    if (!score.failed && score.score <= 3) {
                        currentStreak++;
                        maxStreak = Math.max(maxStreak, currentStreak);
                    } else {
                        currentStreak = 0;
                    }
                });
                if (maxStreak >= 5) {
                    achievements.push({
                        icon: 'üî•',
                        title: 'Hot Streak',
                        desc: '5 games in a row ‚â§ 3',
                        earned: true,
                        progress: `Best streak: ${maxStreak}`
                    });
                }

                // Dedication - 30+ games played
                if (userScores.length >= 30) {
                    achievements.push({
                        icon: 'üí™',
                        title: 'Dedication',
                        desc: '30+ games played',
                        earned: true,
                        progress: `${userScores.length} games`
                    });
                }

                // Marathon Player - 100+ games played
                if (userScores.length >= 100) {
                    achievements.push({
                        icon: 'üèÉ',
                        title: 'Marathon Player',
                        desc: '100+ games played',
                        earned: true,
                        progress: `${userScores.length} games`
                    });
                }

                // Never Give Up - 0 failed games with 20+ attempts
                const failedGames = userScores.filter(s => s.failed).length;
                if (userScores.length >= 20 && failedGames === 0) {
                    achievements.push({
                        icon: 'üõ°Ô∏è',
                        title: 'Never Give Up',
                        desc: 'No failed games with 20+ attempts',
                        earned: true,
                        progress: `${userScores.length} games, ${failedGames} fails`
                    });
                }

                // Comeback Kid - Best score after worst streak
                if (userScores.length >= 10) {
                    let worstStreak = 0;
                    let currentBadStreak = 0;
                    let hadComebackAfterBadStreak = false;

                    for (let i = 0; i < sortedScores.length; i++) {
                        const score = sortedScores[i];
                        if (score.failed || score.score >= 5) {
                            currentBadStreak++;
                            worstStreak = Math.max(worstStreak, currentBadStreak);
                        } else {
                            if (currentBadStreak >= 3 && score.score === 1) {
                                hadComebackAfterBadStreak = true;
                            }
                            currentBadStreak = 0;
                        }
                    }

                    if (hadComebackAfterBadStreak) {
                        achievements.push({
                            icon: 'üîÑ',
                            title: 'Comeback Kid',
                            desc: 'Perfect game after 3+ bad scores',
                            earned: true,
                            progress: `Bounced back with a perfect score`
                        });
                    }
                }

                // === COSTCO-THEMED ACHIEVEMENTS ===

                // Gold Star Member - 50+ games played
                if (userScores.length >= 50) {
                    achievements.push({
                        icon: '‚≠ê',
                        title: 'Gold Star Member',
                        desc: '50+ games played',
                        earned: true,
                        progress: `${userScores.length} games`
                    });
                }

                // Executive Member - 5+ perfect games
                if (perfectGames >= 5) {
                    achievements.push({
                        icon: 'üí≥',
                        title: 'Executive Member',
                        desc: '5+ perfect games',
                        earned: true,
                        progress: `${perfectGames} perfect games`
                    });
                }

                // Hot Dog Combo - Score exactly 1.50 average (impossible but fun)
                // Actually let's make it getting a 2 exactly 15 times
                const exactTwos = completedScores.filter(s => s.score === 2).length;
                if (exactTwos >= 15) {
                    achievements.push({
                        icon: 'üå≠',
                        title: 'Hot Dog Combo',
                        desc: '15 games with score of 2',
                        earned: true,
                        progress: `${exactTwos} perfect twos`
                    });
                }

                // Bulk Buyer - 75+ games played
                if (userScores.length >= 75) {
                    achievements.push({
                        icon: 'üì¶',
                        title: 'Bulk Buyer',
                        desc: '75+ games played',
                        earned: true,
                        progress: `${userScores.length} games`
                    });
                }

                // Food Court Regular - Play 7 days in a row
                const uniqueDates = [...new Set(userScores.map(s => s.date))].sort();
                let maxConsecutiveDays = 0;
                let currentConsecutive = 1;

                for (let i = 1; i < uniqueDates.length; i++) {
                    const prevDate = new Date(uniqueDates[i-1]);
                    const currDate = new Date(uniqueDates[i]);
                    const dayDiff = (currDate - prevDate) / (1000 * 60 * 60 * 24);

                    if (dayDiff === 1) {
                        currentConsecutive++;
                        maxConsecutiveDays = Math.max(maxConsecutiveDays, currentConsecutive);
                    } else {
                        currentConsecutive = 1;
                    }
                }

                if (maxConsecutiveDays >= 7) {
                    achievements.push({
                        icon: 'üçï',
                        title: 'Food Court Regular',
                        desc: '7 consecutive days playing',
                        earned: true,
                        progress: `${maxConsecutiveDays} day streak`
                    });
                }

                // Warehouse Worker - Average score exactly 3.0
                if (completedScores.length >= 10 && avgScore >= 2.95 && avgScore <= 3.05) {
                    achievements.push({
                        icon: 'üè≠',
                        title: 'Warehouse Worker',
                        desc: 'Average score exactly 3.0',
                        earned: true,
                        progress: `${avgScore.toFixed(2)} average`
                    });
                }

                // Sample Station - Try lots of different scores (3+ different score values)
                const uniqueScores = [...new Set(completedScores.map(s => s.score))];
                if (uniqueScores.length >= 4 && userScores.length >= 20) {
                    achievements.push({
                        icon: 'üßÑ',
                        title: 'Sample Station',
                        desc: 'Score 4+ different values (20+ games)',
                        earned: true,
                        progress: `Scored: ${uniqueScores.sort().join(', ')}`
                    });
                }

                userAchievements[username] = achievements;
            });

            console.log('Achievements calculated:', userAchievements);
        }

        // Update performance summary widget
        function updatePerformanceSummary() {
            const container = document.getElementById('performanceSummary');

            if (allScores.length === 0) {
                container.innerHTML = '<p>No data available</p>';
                return;
            }

            // Filter scores for head-to-head mode
            const scoresToConsider = headToHeadMode ?
                allScores.filter(score => HEAD_TO_HEAD_PLAYERS.includes(score.username)) :
                allScores;

            const totalGames = scoresToConsider.length;
            const completedGames = scoresToConsider.filter(s => !s.failed).length;
            const failedGames = scoresToConsider.filter(s => s.failed).length;
            const successRate = totalGames > 0 ? ((completedGames / totalGames) * 100).toFixed(1) : '0';

            const avgScore = completedGames > 0
                ? (scoresToConsider.filter(s => !s.failed).reduce((sum, s) => sum + s.score, 0) / completedGames).toFixed(2)
                : 'N/A';

            const bestScore = completedGames > 0
                ? Math.min(...scoresToConsider.filter(s => !s.failed).map(s => s.score))
                : 'N/A';

            const uniquePlayers = new Set(scoresToConsider.map(s => s.username)).size;
            const daysPlayed = new Set(scoresToConsider.map(s => s.date)).size;

            let html = `
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; font-size: 14px;">
                    <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; text-align: center;">
                        <div style="font-size: 24px; font-weight: bold; color: #667eea;">${totalGames}</div>
                        <div style="color: #666; margin-top: 5px;">Total Games</div>
                    </div>
                    <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; text-align: center;">
                        <div style="font-size: 24px; font-weight: bold; color: #48bb78;">${successRate}%</div>
                        <div style="color: #666; margin-top: 5px;">Success Rate</div>
                    </div>
                    <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; text-align: center;">
                        <div style="font-size: 24px; font-weight: bold; color: #f39c12;">${avgScore}</div>
                        <div style="color: #666; margin-top: 5px;">Avg Score</div>
                    </div>
                    <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; text-align: center;">
                        <div style="font-size: 24px; font-weight: bold; color: #27ae60;">${bestScore}</div>
                        <div style="color: #666; margin-top: 5px;">Best Score</div>
                    </div>
                    <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; text-align: center;">
                        <div style="font-size: 24px; font-weight: bold; color: #9b59b6;">${uniquePlayers}</div>
                        <div style="color: #666; margin-top: 5px;">Players</div>
                    </div>
                    <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; text-align: center;">
                        <div style="font-size: 24px; font-weight: bold; color: #e74c3c;">${daysPlayed}</div>
                        <div style="color: #666; margin-top: 5px;">Days Played</div>
                    </div>
                </div>
            `;

            container.innerHTML = html;
        }

        // Update score heatmap - assumes dates are already in EST timezone from database
        function updateScoreHeatmap() {
            const container = document.getElementById('scoreHeatmap');

            if (allScores.length === 0) {
                container.innerHTML = '<p>No data available</p>';
                return;
            }

            // Filter scores for head-to-head mode
            const scoresToConsider = headToHeadMode ?
                allScores.filter(score => HEAD_TO_HEAD_PLAYERS.includes(score.username)) :
                allScores;

            // Group scores by user and date (already EST from database)
            const users = [...new Set(scoresToConsider.map(s => s.username))].sort();
            const dates = [...new Set(scoresToConsider.map(s => s.date))].sort().reverse();

            const scoreMatrix = {};
            users.forEach(user => {
                scoreMatrix[user] = {};
                dates.forEach(date => {
                    // Get ALL scores for this user on this date
                    const userScoresForDate = scoresToConsider.filter(s => s.username === user && s.date === date);

                    if (userScoresForDate.length > 0) {
                        // If multiple scores on same day, show the best one (lowest number)
                        const bestScore = userScoresForDate.reduce((best, current) => {
                            if (current.failed && !best.failed) return best;
                            if (!current.failed && best.failed) return current;
                            if (current.failed && best.failed) return best;
                            return current.score < best.score ? current : best;
                        });
                        scoreMatrix[user][date] = bestScore;
                    } else {
                        scoreMatrix[user][date] = null;
                    }
                });
            });

            // Create heatmap HTML
            let html = `
                <div style="display: flex; font-size: 16px; font-family: monospace;">
                    <div style="width: 150px; flex-shrink: 0;">
                        <div style="height: 40px;"></div>
            `;

            users.forEach(user => {
                html += `<div style="height: 45px; line-height: 45px; padding-right: 15px; text-align: right; font-weight: bold; font-size: 14px;">${user}</div>`;
            });

            html += '</div><div style="overflow-x: auto; flex-grow: 1;"><div style="display: flex;">';

            dates.forEach(date => {
                const shortDate = date.slice(5); // MM-DD format
                html += `
                    <div style="width: 40px; margin-right: 3px;">
                        <div style="height: 40px; line-height: 40px; text-align: center; font-size: 12px; transform: rotate(-45deg); transform-origin: center;">${shortDate}</div>
                `;

                users.forEach(user => {
                    const score = scoreMatrix[user][date];
                    let bgColor = '#f0f0f0';
                    let textColor = '#999';
                    let displayText = '‚Äî';
                    let cellContent = '';

                    if (score) {
                        if (score.failed) {
                            bgColor = '#2c3e50';
                            textColor = 'white';
                            displayText = 'X';
                        } else {
                            const colors = ['#27ae60', '#2ecc71', '#f39c12', '#e67e22', '#e74c3c', '#c0392b'];
                            bgColor = colors[score.score - 1];
                            textColor = 'white';
                            displayText = score.score;
                        }

                        // Create Discord link if message_id exists
                        if (score.message_id) {
                            const discordLink = `https://discord.com/channels/577258915402612757/1381727975548125346/${score.message_id}`;
                            cellContent = `<a href="${discordLink}" target="_blank" style="color: ${textColor}; text-decoration: none; display: block; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center;">${displayText}</a>`;
                        } else {
                            cellContent = displayText;
                        }
                    } else {
                        cellContent = displayText;
                    }

                    const tooltipText = score ?
                        (score.failed ? 'Failed' : `Score ${score.score}`) +
                        (score.message_id ? ' (Click to view Discord message)' : '') :
                        'No score';

                    html += `
                        <div style="
                            width: 37px;
                            height: 45px;
                            background-color: ${bgColor};
                            color: ${textColor};
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            font-weight: bold;
                            font-size: 16px;
                            border: 1px solid #ddd;
                            ${score && score.message_id ? 'cursor: pointer;' : ''}
                        " title="${user} on ${date}: ${tooltipText}">${cellContent}</div>
                    `;
                });

                html += '</div>';
            });

            html += '</div></div></div>';

            // Add legend
            html += `
                <div style="margin-top: 25px; display: flex; align-items: center; gap: 20px; font-size: 16px;">
                    <span style="font-weight: bold;">Legend:</span>
                    <div style="display: flex; gap: 8px;">
                        <div style="width: 30px; height: 30px; background: #27ae60; color: white; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 16px;">1</div>
                        <div style="width: 30px; height: 30px; background: #2ecc71; color: white; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 16px;">2</div>
                        <div style="width: 30px; height: 30px; background: #f39c12; color: white; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 16px;">3</div>
                        <div style="width: 30px; height: 30px; background: #e67e22; color: white; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 16px;">4</div>
                        <div style="width: 30px; height: 30px; background: #e74c3c; color: white; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 16px;">5</div>
                        <div style="width: 30px; height: 30px; background: #c0392b; color: white; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 16px;">6</div>
                        <div style="width: 30px; height: 30px; background: #2c3e50; color: white; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 16px;">X</div>
                        <div style="width: 30px; height: 30px; background: #f0f0f0; color: #999; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 16px;">‚Äî</div>
                    </div>
                    <span style="margin-left: 15px; color: #666; font-size: 14px;">Green = Better, Red = Worse, X = Failed, ‚Äî = No Score</span>
                    <span style="margin-left: 15px; color: #666; font-size: 12px; font-style: italic;">*Shows best score when multiple games played same day</span>
                    <span style="margin-left: 15px; color: #667eea; font-size: 12px; font-weight: bold;">Click scores to view Discord messages</span>
                </div>
            `;

            container.innerHTML = html;
        }

        // Get performance badge based on average score
        function getPerformanceBadge(avgScore) {
            if (avgScore <= 2.99) return { class: 'best', text: 'Excellent' };
            if (avgScore <= 3.49) return { class: 'good', text: 'Good' };
            if (avgScore <= 3.99) return { class: 'average', text: 'Average' };
            return { class: 'poor', text: 'BJ\'s Member' };
        }

        // Update trends chart with toggle all button
        function updateTrendsChart() {
            const ctx = document.getElementById('trendsChart').getContext('2d');

            // Destroy existing chart if it exists
            if (trendsChart) {
                trendsChart.destroy();
            }

            // Filter scores for head-to-head mode
            const scoresToConsider = headToHeadMode ?
                allScores.filter(score => HEAD_TO_HEAD_PLAYERS.includes(score.username)) :
                allScores;

            // Group scores by user and date
            const userProgress = {};
            scoresToConsider.forEach(score => {
                if (!userProgress[score.username]) {
                    userProgress[score.username] = {};
                }
                userProgress[score.username][score.date] = score.score;
            });

            // Get unique dates and sort them
            const dates = [...new Set(scoresToConsider.map(s => s.date))].sort().reverse();

            // Create datasets for each user with unique colors
            const colors = [
                '#e74c3c', '#3498db', '#f39c12', '#2ecc71', '#9b59b6',
                '#e67e22', '#1abc9c', '#34495e', '#f1c40f', '#8e44ad',
                '#d35400', '#27ae60', '#2980b9', '#c0392b', '#16a085'
            ];
            const datasets = Object.keys(userProgress).map((username, index) => {
                const data = dates.map(date => userProgress[username][date] || null);

                return {
                    label: username,
                    data: data,
                    borderColor: colors[index % colors.length],
                    backgroundColor: colors[index % colors.length] + '20',
                    fill: false,
                    tension: 0.1,
                    spanGaps: true
                };
            });

            trendsChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: dates,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 6,
                            title: {
                                display: true,
                                text: 'Score'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Date'
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: headToHeadMode ? 'Score Trends: .cyco vs clicky6792' : 'Score Trends Over Time'
                        },
                        legend: {
                            onClick: (e, legendItem, legend) => {
                                // Default click behavior
                                Chart.defaults.plugins.legend.onClick(e, legendItem, legend);
                            }
                        }
                    }
                }
            });

            // Add toggle all button
            addToggleAllButton('trendsChart', trendsChart);
        }

        // Update distribution chart
        function updateDistributionChart() {
            const ctx = document.getElementById('distributionChart').getContext('2d');

            // Destroy existing chart if it exists
            if (distributionChart) {
                distributionChart.destroy();
            }

            // Filter scores for head-to-head mode
            const scoresToConsider = headToHeadMode ?
                allScores.filter(score => HEAD_TO_HEAD_PLAYERS.includes(score.username)) :
                allScores;

            // Count score frequencies
            const scoreCounts = {};
            for (let i = 1; i <= 6; i++) {
                scoreCounts[i] = 0;
            }

            scoresToConsider.forEach(score => {
                if (!score.failed) {
                    scoreCounts[score.score]++;
                }
            });

            distributionChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['1', '2', '3', '4', '5', '6'],
                    datasets: [{
                        label: 'Frequency',
                        data: Object.values(scoreCounts),
                        backgroundColor: [
                            '#48bb78',
                            '#4299e1',
                            '#ed8936',
                            '#f56565',
                            '#9f7aea',
                            '#38b2ac'
                        ]
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Number of Games'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Score'
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: headToHeadMode ? 'Score Distribution: .cyco vs clicky6792' : 'Score Distribution'
                        }
                    }
                }
            });
        }

        // Update daily chart
        function updateDailyChart() {
            const ctx = document.getElementById('dailyChart').getContext('2d');

            // Destroy existing chart if it exists
            if (dailyChart) {
                dailyChart.destroy();
            }

            // Filter daily stats for head-to-head mode if needed
            let dailyStatsToUse = dailyStats;
            if (headToHeadMode) {
                // Recalculate daily stats for just the head-to-head players
                const h2hScores = allScores.filter(score => HEAD_TO_HEAD_PLAYERS.includes(score.username));
                const dailyData = {};

                h2hScores.forEach(score => {
                    if (!dailyData[score.date]) {
                        dailyData[score.date] = { scores: [], failed: 0 };
                    }
                    if (score.failed) {
                        dailyData[score.date].failed++;
                    } else {
                        dailyData[score.date].scores.push(score.score);
                    }
                });

                dailyStatsToUse = Object.keys(dailyData).map(date => {
                    const dayData = dailyData[date];
                    const scores = dayData.scores;
                    return {
                        date: date,
                        players: scores.length + dayData.failed,
                        avg_score: scores.length > 0 ? (scores.reduce((sum, s) => sum + s, 0) / scores.length).toFixed(2) : null,
                        best_score: scores.length > 0 ? Math.min(...scores) : null,
                        worst_score: scores.length > 0 ? Math.max(...scores) : null,
                        failed_count: dayData.failed
                    };
                }).filter(d => d.avg_score !== null);
            }

            //const sortedDaily = dailyStatsToUse.sort((a, b) => new Date(a.date) - new Date(b.date));
            const sortedDaily = dailyStatsToUse.sort((a, b) => new Date(b.date) - new Date(a.date));

            dailyChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: sortedDaily.map(d => d.date),
                    datasets: [{
                        label: 'Daily Average',
                        data: sortedDaily.map(d => d.avg_score),
                        borderColor: '#667eea',
                        backgroundColor: '#667eea20',
                        tension: 0.1
                    }, {
                        label: 'Best Score',
                        data: sortedDaily.map(d => d.best_score),
                        borderColor: '#48bb78',
                        backgroundColor: '#48bb7820',
                        tension: 0.1
                    }, {
                        label: 'Worst Score',
                        data: sortedDaily.map(d => d.worst_score),
                        borderColor: '#e74c3c',
                        backgroundColor: '#e74c3c20',
                        tension: 0.1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 6,
                            title: {
                                display: true,
                                text: 'Score'
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: headToHeadMode ? 'Daily Performance: .cyco vs clicky6792' : 'Daily Performance'
                        }
                    }
                }
            });
        }

        // Update progress chart (moving average) with toggle all button
        function updateProgressChart() {
            const ctx = document.getElementById('progressChart').getContext('2d');

            // Destroy existing chart if it exists
            if (progressChart) {
                progressChart.destroy();
            }

            // Filter scores for head-to-head mode
            const scoresToConsider = headToHeadMode ?
                allScores.filter(score => HEAD_TO_HEAD_PLAYERS.includes(score.username)) :
                allScores;

            // Calculate 7-day moving average for each user with unique colors
            const users = [...new Set(scoresToConsider.map(s => s.username))];
            const colors = [
                '#e74c3c', '#3498db', '#f39c12', '#2ecc71', '#9b59b6',
                '#e67e22', '#1abc9c', '#34495e', '#f1c40f', '#8e44ad',
                '#d35400', '#27ae60', '#2980b9', '#c0392b', '#16a085'
            ];
            const datasets = users.map((username, index) => {
                const userScores = scoresToConsider.filter(s => s.username === username && !s.failed)
                    .sort((a, b) => new Date(a.date) - new Date(b.date));

                const movingAvg = [];
                for (let i = 0; i < userScores.length; i++) {
                    const start = Math.max(0, i - 6);
                    const subset = userScores.slice(start, i + 1);
                    const avg = subset.reduce((sum, s) => sum + s.score, 0) / subset.length;
                    movingAvg.push(avg);
                }

                return {
                    label: username,
                    data: movingAvg,
                    borderColor: colors[index % colors.length],
                    backgroundColor: colors[index % colors.length] + '20',
                    fill: false,
                    tension: 0.1
                };
            });

            progressChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: Array.from({length: Math.max(...datasets.map(d => d.data.length))}, (_, i) => i + 1),
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 6,
                            title: {
                                display: true,
                                text: 'Moving Average Score'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Game Number'
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: headToHeadMode ? '7-Game Moving Average: .cyco vs clicky6792' : '7-Game Moving Average'
                        },
                        legend: {
                            onClick: (e, legendItem, legend) => {
                                // Default click behavior
                                Chart.defaults.plugins.legend.onClick(e, legendItem, legend);
                            }
                        }
                    }
                }
            });

            // Add toggle all button
            addToggleAllButton('progressChart', progressChart);
        }

        // Function to add toggle all button to charts
        function addToggleAllButton(chartId, chartInstance) {
            const chartContainer = document.getElementById(chartId).parentElement;

            // Remove existing button if it exists
            const existingButton = chartContainer.querySelector('.toggle-all-btn');
            if (existingButton) {
                existingButton.remove();
            }

            // Create toggle all button
            const toggleButton = document.createElement('button');
            toggleButton.className = 'toggle-all-btn';
            toggleButton.textContent = 'Hide All';
            toggleButton.style.cssText = `
                position: absolute;
                top: 10px;
                right: 10px;
                background: #667eea;
                color: white;
                border: none;
                padding: 6px 12px;
                border-radius: 4px;
                cursor: pointer;
                font-size: 12px;
                z-index: 1000;
            `;

            let allHidden = false;

            toggleButton.addEventListener('click', () => {
                if (allHidden) {
                    // Show all datasets
                    chartInstance.data.datasets.forEach((dataset, index) => {
                        chartInstance.setDatasetVisibility(index, true);
                    });
                    toggleButton.textContent = 'Hide All';
                    allHidden = false;
                } else {
                    // Hide all datasets
                    chartInstance.data.datasets.forEach((dataset, index) => {
                        chartInstance.setDatasetVisibility(index, false);
                    });
                    toggleButton.textContent = 'Show All';
                    allHidden = true;
                }
                chartInstance.update();
            });

            chartContainer.style.position = 'relative';
            chartContainer.appendChild(toggleButton);
        }

        // Export data to CSV - Fixed to include all data and sort by message_date
        function exportData() {
            if (allScores.length === 0) {
                showMessage('No data to export. Please refresh data first.', 'error');
                return;
            }

            // Filter scores for head-to-head mode if active
            const scoresToExport = headToHeadMode ?
                allScores.filter(score => HEAD_TO_HEAD_PLAYERS.includes(score.username)) :
                allScores;

            // Sort by message_date (or created_at as fallback) descending
            const sortedScores = [...scoresToExport].sort((a, b) => {
                const dateA = new Date(a.message_date || a.created_at);
                const dateB = new Date(b.message_date || b.created_at);
                return dateB - dateA; // Most recent first
            });

            let csv = 'Date,Username,Score,Failed,Message_ID,Message_Date,Created_At\n';
            sortedScores.forEach(score => {
                const displayScore = score.failed ? 'X' : score.score;
                const failed = score.failed ? 'true' : 'false';
                const messageDate = score.message_date || '';
                const createdAt = score.created_at || '';
                csv += `${score.date},"${score.username}",${displayScore},${failed},"${score.message_id}","${messageDate}","${createdAt}"\n`;
            });

            const blob = new Blob([csv], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const filename = headToHeadMode ?
                `costcodle_head_to_head_${new Date().toISOString().split('T')[0]}.csv` :
                `costcodle_scores_${new Date().toISOString().split('T')[0]}.csv`;
            a.download = filename;
            a.click();
            window.URL.revokeObjectURL(url);

            const modeText = headToHeadMode ? ' (Head-to-Head)' : '';
            showMessage(`Exported ${sortedScores.length} scores to CSV${modeText}`, 'success');
        }

        // Initialize the dashboard
        init();
    </script>
</body>
</html>
